"use strict";
Object.defineProperties(module.exports, {
  View: {get: function() {
      return View;
    }},
  ProtoView: {get: function() {
      return ProtoView;
    }},
  ElementBindingMemento: {get: function() {
      return ElementBindingMemento;
    }},
  DirectiveBindingMemento: {get: function() {
      return DirectiveBindingMemento;
    }},
  PropertyUpdate: {get: function() {
      return PropertyUpdate;
    }},
  __esModule: {value: true}
});
var $__rtts_95_assert_47_rtts_95_assert__,
    $__angular2_47_src_47_dom_47_dom_95_adapter__,
    $__angular2_47_src_47_facade_47_async__,
    $__angular2_47_src_47_facade_47_collection__,
    $__angular2_47_change_95_detection__,
    $__element_95_injector__,
    $__element_95_binder__,
    $__directive_95_metadata__,
    $__angular2_47_src_47_reflection_47_types__,
    $__angular2_47_src_47_facade_47_lang__,
    $__angular2_47_di__,
    $__angular2_47_src_47_core_47_dom_47_element__,
    $__view_95_container__,
    $__shadow_95_dom_95_emulation_47_light_95_dom__,
    $__shadow_95_dom_95_emulation_47_content_95_tag__,
    $__shadow_95_dom_95_strategy__,
    $__view_95_pool__,
    $__angular2_47_src_47_core_47_events_47_event_95_manager__;
var assert = ($__rtts_95_assert_47_rtts_95_assert__ = require("rtts_assert/rtts_assert"), $__rtts_95_assert_47_rtts_95_assert__ && $__rtts_95_assert_47_rtts_95_assert__.__esModule && $__rtts_95_assert_47_rtts_95_assert__ || {default: $__rtts_95_assert_47_rtts_95_assert__}).assert;
var DOM = ($__angular2_47_src_47_dom_47_dom_95_adapter__ = require("angular2/src/dom/dom_adapter"), $__angular2_47_src_47_dom_47_dom_95_adapter__ && $__angular2_47_src_47_dom_47_dom_95_adapter__.__esModule && $__angular2_47_src_47_dom_47_dom_95_adapter__ || {default: $__angular2_47_src_47_dom_47_dom_95_adapter__}).DOM;
var Promise = ($__angular2_47_src_47_facade_47_async__ = require("angular2/src/facade/async"), $__angular2_47_src_47_facade_47_async__ && $__angular2_47_src_47_facade_47_async__.__esModule && $__angular2_47_src_47_facade_47_async__ || {default: $__angular2_47_src_47_facade_47_async__}).Promise;
var $__3 = ($__angular2_47_src_47_facade_47_collection__ = require("angular2/src/facade/collection"), $__angular2_47_src_47_facade_47_collection__ && $__angular2_47_src_47_facade_47_collection__.__esModule && $__angular2_47_src_47_facade_47_collection__ || {default: $__angular2_47_src_47_facade_47_collection__}),
    ListWrapper = $__3.ListWrapper,
    MapWrapper = $__3.MapWrapper,
    Map = $__3.Map,
    StringMapWrapper = $__3.StringMapWrapper,
    List = $__3.List;
var $__4 = ($__angular2_47_change_95_detection__ = require("angular2/change_detection"), $__angular2_47_change_95_detection__ && $__angular2_47_change_95_detection__.__esModule && $__angular2_47_change_95_detection__ || {default: $__angular2_47_change_95_detection__}),
    AST = $__4.AST,
    Locals = $__4.Locals,
    ChangeDispatcher = $__4.ChangeDispatcher,
    ProtoChangeDetector = $__4.ProtoChangeDetector,
    ChangeDetector = $__4.ChangeDetector,
    ChangeRecord = $__4.ChangeRecord,
    BindingRecord = $__4.BindingRecord,
    BindingPropagationConfig = $__4.BindingPropagationConfig,
    uninitialized = $__4.uninitialized;
var $__5 = ($__element_95_injector__ = require("./element_injector"), $__element_95_injector__ && $__element_95_injector__.__esModule && $__element_95_injector__ || {default: $__element_95_injector__}),
    ProtoElementInjector = $__5.ProtoElementInjector,
    ElementInjector = $__5.ElementInjector,
    PreBuiltObjects = $__5.PreBuiltObjects;
var ElementBinder = ($__element_95_binder__ = require("./element_binder"), $__element_95_binder__ && $__element_95_binder__.__esModule && $__element_95_binder__ || {default: $__element_95_binder__}).ElementBinder;
var DirectiveMetadata = ($__directive_95_metadata__ = require("./directive_metadata"), $__directive_95_metadata__ && $__directive_95_metadata__.__esModule && $__directive_95_metadata__ || {default: $__directive_95_metadata__}).DirectiveMetadata;
var SetterFn = ($__angular2_47_src_47_reflection_47_types__ = require("angular2/src/reflection/types"), $__angular2_47_src_47_reflection_47_types__ && $__angular2_47_src_47_reflection_47_types__.__esModule && $__angular2_47_src_47_reflection_47_types__ || {default: $__angular2_47_src_47_reflection_47_types__}).SetterFn;
var $__9 = ($__angular2_47_src_47_facade_47_lang__ = require("angular2/src/facade/lang"), $__angular2_47_src_47_facade_47_lang__ && $__angular2_47_src_47_facade_47_lang__.__esModule && $__angular2_47_src_47_facade_47_lang__ || {default: $__angular2_47_src_47_facade_47_lang__}),
    IMPLEMENTS = $__9.IMPLEMENTS,
    int = $__9.int,
    isPresent = $__9.isPresent,
    isBlank = $__9.isBlank,
    BaseException = $__9.BaseException;
var Injector = ($__angular2_47_di__ = require("angular2/di"), $__angular2_47_di__ && $__angular2_47_di__.__esModule && $__angular2_47_di__ || {default: $__angular2_47_di__}).Injector;
var NgElement = ($__angular2_47_src_47_core_47_dom_47_element__ = require("angular2/src/core/dom/element"), $__angular2_47_src_47_core_47_dom_47_element__ && $__angular2_47_src_47_core_47_dom_47_element__.__esModule && $__angular2_47_src_47_core_47_dom_47_element__ || {default: $__angular2_47_src_47_core_47_dom_47_element__}).NgElement;
var ViewContainer = ($__view_95_container__ = require("./view_container"), $__view_95_container__ && $__view_95_container__.__esModule && $__view_95_container__ || {default: $__view_95_container__}).ViewContainer;
var LightDom = ($__shadow_95_dom_95_emulation_47_light_95_dom__ = require("./shadow_dom_emulation/light_dom"), $__shadow_95_dom_95_emulation_47_light_95_dom__ && $__shadow_95_dom_95_emulation_47_light_95_dom__.__esModule && $__shadow_95_dom_95_emulation_47_light_95_dom__ || {default: $__shadow_95_dom_95_emulation_47_light_95_dom__}).LightDom;
var Content = ($__shadow_95_dom_95_emulation_47_content_95_tag__ = require("./shadow_dom_emulation/content_tag"), $__shadow_95_dom_95_emulation_47_content_95_tag__ && $__shadow_95_dom_95_emulation_47_content_95_tag__.__esModule && $__shadow_95_dom_95_emulation_47_content_95_tag__ || {default: $__shadow_95_dom_95_emulation_47_content_95_tag__}).Content;
var ShadowDomStrategy = ($__shadow_95_dom_95_strategy__ = require("./shadow_dom_strategy"), $__shadow_95_dom_95_strategy__ && $__shadow_95_dom_95_strategy__.__esModule && $__shadow_95_dom_95_strategy__ || {default: $__shadow_95_dom_95_strategy__}).ShadowDomStrategy;
var ViewPool = ($__view_95_pool__ = require("./view_pool"), $__view_95_pool__ && $__view_95_pool__.__esModule && $__view_95_pool__ || {default: $__view_95_pool__}).ViewPool;
var EventManager = ($__angular2_47_src_47_core_47_events_47_event_95_manager__ = require("angular2/src/core/events/event_manager"), $__angular2_47_src_47_core_47_events_47_event_95_manager__ && $__angular2_47_src_47_core_47_events_47_event_95_manager__.__esModule && $__angular2_47_src_47_core_47_events_47_event_95_manager__ || {default: $__angular2_47_src_47_core_47_events_47_event_95_manager__}).EventManager;
var NG_BINDING_CLASS = 'ng-binding';
var NG_BINDING_CLASS_SELECTOR = '.ng-binding';
var VIEW_POOL_CAPACITY = 10000;
var VIEW_POOL_PREFILL = 0;
var View = function View(proto, nodes, protoLocals) {
  assert.argumentTypes(proto, ProtoView, nodes, List, protoLocals, Map);
  this.proto = proto;
  this.nodes = nodes;
  this.changeDetector = null;
  this.elementInjectors = null;
  this.rootElementInjectors = null;
  this.textNodes = null;
  this.bindElements = null;
  this.componentChildViews = null;
  this.viewContainers = null;
  this.contentTags = null;
  this.preBuiltObjects = null;
  this.lightDoms = null;
  this.context = null;
  this.locals = new Locals(null, MapWrapper.clone(protoLocals));
};
($traceurRuntime.createClass)(View, {
  init: function(changeDetector, elementInjectors, rootElementInjectors, textNodes, bindElements, viewContainers, contentTags, preBuiltObjects, componentChildViews, lightDoms) {
    assert.argumentTypes(changeDetector, ChangeDetector, elementInjectors, List, rootElementInjectors, List, textNodes, List, bindElements, List, viewContainers, List, contentTags, List, preBuiltObjects, List, componentChildViews, List, lightDoms, assert.genericType(List, LightDom));
    this.changeDetector = changeDetector;
    this.elementInjectors = elementInjectors;
    this.rootElementInjectors = rootElementInjectors;
    this.textNodes = textNodes;
    this.bindElements = bindElements;
    this.viewContainers = viewContainers;
    this.contentTags = contentTags;
    this.preBuiltObjects = preBuiltObjects;
    this.componentChildViews = componentChildViews;
    this.lightDoms = lightDoms;
  },
  setLocal: function(contextName, value) {
    assert.argumentTypes(contextName, assert.type.string, value, assert.type.any);
    if (!this.hydrated())
      throw new BaseException('Cannot set locals on dehydrated view.');
    if (!MapWrapper.contains(this.proto.variableBindings, contextName)) {
      return ;
    }
    var templateName = MapWrapper.get(this.proto.variableBindings, contextName);
    this.locals.set(templateName, value);
  },
  hydrated: function() {
    return isPresent(this.context);
  },
  _hydrateContext: function(newContext, locals) {
    this.context = newContext;
    this.locals.parent = locals;
    this.changeDetector.hydrate(this.context, this.locals);
  },
  _dehydrateContext: function() {
    if (isPresent(this.locals)) {
      this.locals.clearValues();
    }
    this.context = null;
    this.changeDetector.dehydrate();
  },
  hydrate: function(appInjector, hostElementInjector, hostLightDom, context, locals) {
    assert.argumentTypes(appInjector, Injector, hostElementInjector, ElementInjector, hostLightDom, LightDom, context, Object, locals, Locals);
    if (this.hydrated())
      throw new BaseException('The view is already hydrated.');
    this._hydrateContext(context, locals);
    for (var i = 0; i < this.viewContainers.length; i++) {
      var vc = this.viewContainers[i];
      if (isPresent(vc)) {
        vc.hydrate(appInjector, hostElementInjector, hostLightDom);
      }
    }
    var binders = this.proto.elementBinders;
    var componentChildViewIndex = 0;
    for (var i = 0; i < binders.length; ++i) {
      var componentDirective = binders[i].componentDirective;
      var shadowDomAppInjector = null;
      if (isPresent(componentDirective)) {
        var services = componentDirective.annotation.services;
        if (isPresent(services))
          shadowDomAppInjector = appInjector.createChild(services);
        else {
          shadowDomAppInjector = appInjector;
        }
      } else {
        shadowDomAppInjector = null;
      }
      var elementInjector = this.elementInjectors[i];
      if (isPresent(elementInjector)) {
        elementInjector.instantiateDirectives(appInjector, shadowDomAppInjector, this.preBuiltObjects[i]);
        var exportImplicitName = elementInjector.getExportImplicitName();
        if (elementInjector.isExportingComponent()) {
          this.locals.set(exportImplicitName, elementInjector.getComponent());
        } else if (elementInjector.isExportingElement()) {
          this.locals.set(exportImplicitName, elementInjector.getNgElement().domElement);
        }
      }
      if (isPresent(binders[i].nestedProtoView) && isPresent(componentDirective)) {
        this.componentChildViews[componentChildViewIndex++].hydrate(shadowDomAppInjector, elementInjector, this.lightDoms[i], elementInjector.getComponent(), null);
      }
    }
    for (var i = 0; i < this.lightDoms.length; ++i) {
      var lightDom = this.lightDoms[i];
      if (isPresent(lightDom)) {
        lightDom.redistribute();
      }
    }
  },
  dehydrate: function() {
    for (var i = 0; i < this.componentChildViews.length; i++) {
      this.componentChildViews[i].dehydrate();
    }
    for (var i = 0; i < this.elementInjectors.length; i++) {
      if (isPresent(this.elementInjectors[i])) {
        this.elementInjectors[i].clearDirectives();
      }
    }
    if (isPresent(this.viewContainers)) {
      for (var i = 0; i < this.viewContainers.length; i++) {
        var vc = this.viewContainers[i];
        if (isPresent(vc)) {
          vc.dehydrate();
        }
      }
    }
    this._dehydrateContext();
  },
  triggerEventHandlers: function(eventName, eventObj, binderIndex) {
    assert.argumentTypes(eventName, assert.type.string, eventObj, assert.type.any, binderIndex, int);
    var handlers = this.proto.eventHandlers[binderIndex];
    if (isBlank(handlers))
      return ;
    var handler = StringMapWrapper.get(handlers, eventName);
    if (isBlank(handler))
      return ;
    handler(eventObj, this);
  },
  onRecordChange: function(directiveMemento, records) {
    assert.argumentTypes(directiveMemento, assert.type.any, records, List);
    this._invokeMementos(records);
    if (directiveMemento instanceof DirectiveMemento) {
      this._notifyDirectiveAboutChanges(directiveMemento, records);
    }
  },
  onAllChangesDone: function(directiveMemento) {
    var dir = directiveMemento.directive(this.elementInjectors);
    dir.onAllChangesDone();
  },
  _invokeMementos: function(records) {
    assert.argumentTypes(records, List);
    for (var i = 0; i < records.length; ++i) {
      this._invokeMementoFor(records[i]);
    }
  },
  _notifyDirectiveAboutChanges: function(directiveMemento, records) {
    assert.argumentTypes(directiveMemento, assert.type.any, records, List);
    var dir = directiveMemento.directive(this.elementInjectors);
    var binding = directiveMemento.directiveBinding(this.elementInjectors);
    if (binding.callOnChange) {
      dir.onChange(this._collectChanges(records));
    }
  },
  _invokeMementoFor: function(record) {
    assert.argumentTypes(record, ChangeRecord);
    var memento = record.bindingMemento;
    if (memento instanceof DirectiveBindingMemento) {
      var directiveMemento = assert.type(memento, DirectiveBindingMemento);
      directiveMemento.invoke(record, this.elementInjectors);
    } else if (memento instanceof ElementBindingMemento) {
      var elementMemento = assert.type(memento, ElementBindingMemento);
      elementMemento.invoke(record, this.bindElements);
    } else {
      var textNodeIndex = assert.type(memento, assert.type.number);
      DOM.setText(this.textNodes[textNodeIndex], record.currentValue);
    }
  },
  _collectChanges: function(records) {
    assert.argumentTypes(records, List);
    var changes = StringMapWrapper.create();
    for (var i = 0; i < records.length; ++i) {
      var record = records[i];
      var propertyUpdate = new PropertyUpdate(record.currentValue, record.previousValue);
      StringMapWrapper.set(changes, record.bindingMemento._setterName, propertyUpdate);
    }
    return changes;
  }
}, {});
Object.defineProperty(View, "annotations", {get: function() {
    return [new IMPLEMENTS(ChangeDispatcher)];
  }});
Object.defineProperty(View, "parameters", {get: function() {
    return [[ProtoView], [List], [Map]];
  }});
Object.defineProperty(View.prototype.init, "parameters", {get: function() {
    return [[ChangeDetector], [List], [List], [List], [List], [List], [List], [List], [List], [assert.genericType(List, LightDom)]];
  }});
Object.defineProperty(View.prototype.setLocal, "parameters", {get: function() {
    return [[assert.type.string], []];
  }});
Object.defineProperty(View.prototype.hydrate, "parameters", {get: function() {
    return [[Injector], [ElementInjector], [LightDom], [Object], [Locals]];
  }});
Object.defineProperty(View.prototype.triggerEventHandlers, "parameters", {get: function() {
    return [[assert.type.string], [], [int]];
  }});
Object.defineProperty(View.prototype.onRecordChange, "parameters", {get: function() {
    return [[], [List]];
  }});
Object.defineProperty(View.prototype._invokeMementos, "parameters", {get: function() {
    return [[List]];
  }});
Object.defineProperty(View.prototype._notifyDirectiveAboutChanges, "parameters", {get: function() {
    return [[], [List]];
  }});
Object.defineProperty(View.prototype._invokeMementoFor, "parameters", {get: function() {
    return [[ChangeRecord]];
  }});
Object.defineProperty(View.prototype._collectChanges, "parameters", {get: function() {
    return [[List]];
  }});
var ProtoView = function ProtoView(template, protoChangeDetector, shadowDomStrategy) {
  var parentProtoView = arguments[3] !== (void 0) ? arguments[3] : null;
  assert.argumentTypes(template, assert.type.any, protoChangeDetector, ProtoChangeDetector, shadowDomStrategy, ShadowDomStrategy, parentProtoView, $ProtoView);
  this.element = template;
  this.elementBinders = [];
  this.variableBindings = MapWrapper.create();
  this.protoLocals = MapWrapper.create();
  this.protoChangeDetector = protoChangeDetector;
  this.parentProtoView = parentProtoView;
  this.textNodesWithBindingCount = 0;
  this.elementsWithBindingCount = 0;
  this.instantiateInPlace = false;
  this.rootBindingOffset = (isPresent(this.element) && DOM.hasClass(this.element, NG_BINDING_CLASS)) ? 1 : 0;
  this.isTemplateElement = DOM.isTemplateElement(this.element);
  this.shadowDomStrategy = shadowDomStrategy;
  this._viewPool = new ViewPool(VIEW_POOL_CAPACITY);
  this.stylePromises = [];
  this.eventHandlers = [];
  this.bindingRecords = [];
  this._directiveMementosMap = MapWrapper.create();
  this._variableBindings = null;
  this._directiveMementos = null;
};
var $ProtoView = ProtoView;
($traceurRuntime.createClass)(ProtoView, {
  instantiate: function(hostElementInjector, eventManager) {
    assert.argumentTypes(hostElementInjector, ElementInjector, eventManager, EventManager);
    if (this._viewPool.length() == 0)
      this._preFillPool(hostElementInjector, eventManager);
    var view = this._viewPool.pop();
    return assert.returnType((isPresent(view) ? view : this._instantiate(hostElementInjector, eventManager)), View);
  },
  _preFillPool: function(hostElementInjector, eventManager) {
    assert.argumentTypes(hostElementInjector, ElementInjector, eventManager, EventManager);
    for (var i = 0; i < VIEW_POOL_PREFILL; i++) {
      this._viewPool.push(this._instantiate(hostElementInjector, eventManager));
    }
  },
  _getVariableBindings: function() {
    var $__18 = this;
    if (isPresent(this._variableBindings)) {
      return this._variableBindings;
    }
    this._variableBindings = isPresent(this.parentProtoView) ? ListWrapper.clone(this.parentProtoView._getVariableBindings()) : [];
    MapWrapper.forEach(this.protoLocals, (function(v, local) {
      ListWrapper.push($__18._variableBindings, local);
    }));
    return this._variableBindings;
  },
  _getDirectiveMementos: function() {
    if (isPresent(this._directiveMementos)) {
      return this._directiveMementos;
    }
    this._directiveMementos = [];
    for (var injectorIndex = 0; injectorIndex < this.elementBinders.length; ++injectorIndex) {
      var pei = this.elementBinders[injectorIndex].protoElementInjector;
      if (isPresent(pei)) {
        for (var directiveIndex = 0; directiveIndex < pei.numberOfDirectives; ++directiveIndex) {
          ListWrapper.push(this._directiveMementos, this._getDirectiveMemento(injectorIndex, directiveIndex));
        }
      }
    }
    return this._directiveMementos;
  },
  _instantiate: function(hostElementInjector, eventManager) {
    assert.argumentTypes(hostElementInjector, ElementInjector, eventManager, EventManager);
    var rootElementClone = this.instantiateInPlace ? this.element : DOM.importIntoDoc(this.element);
    var elementsWithBindingsDynamic;
    if (this.isTemplateElement) {
      elementsWithBindingsDynamic = DOM.querySelectorAll(DOM.content(rootElementClone), NG_BINDING_CLASS_SELECTOR);
    } else {
      elementsWithBindingsDynamic = DOM.getElementsByClassName(rootElementClone, NG_BINDING_CLASS);
    }
    var elementsWithBindings = ListWrapper.createFixedSize(elementsWithBindingsDynamic.length);
    for (var binderIdx = 0; binderIdx < elementsWithBindingsDynamic.length; ++binderIdx) {
      elementsWithBindings[binderIdx] = elementsWithBindingsDynamic[binderIdx];
    }
    var viewNodes;
    if (this.isTemplateElement) {
      var childNode = DOM.firstChild(DOM.content(rootElementClone));
      viewNodes = [];
      while (childNode != null) {
        ListWrapper.push(viewNodes, childNode);
        childNode = DOM.nextSibling(childNode);
      }
    } else {
      viewNodes = [rootElementClone];
    }
    var view = new View(this, viewNodes, this.protoLocals);
    var changeDetector = this.protoChangeDetector.instantiate(view, this.bindingRecords, this._getVariableBindings(), this._getDirectiveMementos());
    var binders = this.elementBinders;
    var elementInjectors = ListWrapper.createFixedSize(binders.length);
    var eventHandlers = ListWrapper.createFixedSize(binders.length);
    var rootElementInjectors = [];
    var textNodes = [];
    var elementsWithPropertyBindings = [];
    var preBuiltObjects = ListWrapper.createFixedSize(binders.length);
    var viewContainers = ListWrapper.createFixedSize(binders.length);
    var contentTags = ListWrapper.createFixedSize(binders.length);
    var componentChildViews = [];
    var lightDoms = ListWrapper.createFixedSize(binders.length);
    for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
      var binder = binders[binderIdx];
      var element = void 0;
      if (binderIdx === 0 && this.rootBindingOffset === 1) {
        element = rootElementClone;
      } else {
        element = elementsWithBindings[binderIdx - this.rootBindingOffset];
      }
      var elementInjector = null;
      var protoElementInjector = binder.protoElementInjector;
      if (isPresent(protoElementInjector)) {
        if (isPresent(protoElementInjector.parent)) {
          var parentElementInjector = elementInjectors[protoElementInjector.parent.index];
          elementInjector = protoElementInjector.instantiate(parentElementInjector, null);
        } else {
          elementInjector = protoElementInjector.instantiate(null, hostElementInjector);
          ListWrapper.push(rootElementInjectors, elementInjector);
        }
      }
      elementInjectors[binderIdx] = elementInjector;
      if (binder.hasElementPropertyBindings) {
        ListWrapper.push(elementsWithPropertyBindings, element);
      }
      var textNodeIndices = binder.textNodeIndices;
      if (isPresent(textNodeIndices)) {
        var childNode = DOM.firstChild(DOM.templateAwareRoot(element));
        for (var j = 0,
            k = 0; j < textNodeIndices.length; j++) {
          for (var index = textNodeIndices[j]; k < index; k++) {
            childNode = DOM.nextSibling(childNode);
          }
          ListWrapper.push(textNodes, childNode);
        }
      }
      var lightDom = null;
      var bindingPropagationConfig = null;
      if (isPresent(binder.nestedProtoView) && isPresent(binder.componentDirective)) {
        var strategy = this.shadowDomStrategy;
        var childView = binder.nestedProtoView.instantiate(elementInjector, eventManager);
        changeDetector.addChild(childView.changeDetector);
        lightDom = strategy.constructLightDom(view, childView, element);
        strategy.attachTemplate(element, childView);
        bindingPropagationConfig = new BindingPropagationConfig(childView.changeDetector);
        ListWrapper.push(componentChildViews, childView);
      }
      lightDoms[binderIdx] = lightDom;
      var destLightDom = null;
      if (isPresent(binder.parent) && binder.distanceToParent === 1) {
        destLightDom = lightDoms[binder.parent.index];
      }
      var viewContainer = null;
      if (isPresent(binder.viewportDirective)) {
        viewContainer = new ViewContainer(view, element, binder.nestedProtoView, elementInjector, eventManager, destLightDom);
      }
      viewContainers[binderIdx] = viewContainer;
      var contentTag = null;
      if (isPresent(binder.contentTagSelector)) {
        contentTag = new Content(destLightDom, element, binder.contentTagSelector);
      }
      contentTags[binderIdx] = contentTag;
      if (isPresent(elementInjector)) {
        preBuiltObjects[binderIdx] = new PreBuiltObjects(view, new NgElement(element), viewContainer, bindingPropagationConfig);
      }
      if (isPresent(binder.events)) {
        eventHandlers[binderIdx] = StringMapWrapper.create();
        StringMapWrapper.forEach(binder.events, (function(eventMap, eventName) {
          var handler = $ProtoView.buildEventHandler(eventMap, binderIdx);
          StringMapWrapper.set(eventHandlers[binderIdx], eventName, handler);
          if (isBlank(elementInjector) || !elementInjector.hasEventEmitter(eventName)) {
            eventManager.addEventListener(element, eventName, (function(event) {
              handler(event, view);
            }));
          }
        }));
      }
    }
    this.eventHandlers = eventHandlers;
    view.init(changeDetector, elementInjectors, rootElementInjectors, textNodes, elementsWithPropertyBindings, viewContainers, contentTags, preBuiltObjects, componentChildViews, lightDoms);
    return assert.returnType((view), View);
  },
  returnToPool: function(view) {
    assert.argumentTypes(view, View);
    this._viewPool.push(view);
  },
  bindVariable: function(contextName, templateName) {
    assert.argumentTypes(contextName, assert.type.string, templateName, assert.type.string);
    MapWrapper.set(this.variableBindings, contextName, templateName);
    MapWrapper.set(this.protoLocals, templateName, null);
  },
  bindElement: function(parent, distanceToParent, protoElementInjector) {
    var componentDirective = arguments[3] !== (void 0) ? arguments[3] : null;
    var viewportDirective = arguments[4] !== (void 0) ? arguments[4] : null;
    assert.argumentTypes(parent, ElementBinder, distanceToParent, int, protoElementInjector, ProtoElementInjector, componentDirective, DirectiveMetadata, viewportDirective, DirectiveMetadata);
    var elBinder = new ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective, viewportDirective);
    ListWrapper.push(this.elementBinders, elBinder);
    return assert.returnType((elBinder), ElementBinder);
  },
  bindTextNode: function(indexInParent, expression) {
    assert.argumentTypes(indexInParent, int, expression, AST);
    var elBinder = this.elementBinders[this.elementBinders.length - 1];
    if (isBlank(elBinder.textNodeIndices)) {
      elBinder.textNodeIndices = ListWrapper.create();
    }
    ListWrapper.push(elBinder.textNodeIndices, indexInParent);
    var memento = this.textNodesWithBindingCount++;
    ListWrapper.push(this.bindingRecords, new BindingRecord(expression, memento, null));
  },
  bindElementProperty: function(expression, setterName, setter) {
    assert.argumentTypes(expression, AST, setterName, assert.type.string, setter, SetterFn);
    var elBinder = this.elementBinders[this.elementBinders.length - 1];
    if (!elBinder.hasElementPropertyBindings) {
      elBinder.hasElementPropertyBindings = true;
      this.elementsWithBindingCount++;
    }
    var memento = new ElementBindingMemento(this.elementsWithBindingCount - 1, setterName, setter);
    ListWrapper.push(this.bindingRecords, new BindingRecord(expression, memento, null));
  },
  bindEvent: function(eventName, expression) {
    var directiveIndex = arguments[2] !== (void 0) ? arguments[2] : -1;
    assert.argumentTypes(eventName, assert.type.string, expression, AST, directiveIndex, int);
    var elBinder = this.elementBinders[this.elementBinders.length - 1];
    var events = elBinder.events;
    if (isBlank(events)) {
      events = StringMapWrapper.create();
      elBinder.events = events;
    }
    var event = StringMapWrapper.get(events, eventName);
    if (isBlank(event)) {
      event = MapWrapper.create();
      StringMapWrapper.set(events, eventName, event);
    }
    MapWrapper.set(event, directiveIndex, expression);
  },
  bindDirectiveProperty: function(directiveIndex, expression, setterName, setter) {
    assert.argumentTypes(directiveIndex, assert.type.number, expression, AST, setterName, assert.type.string, setter, SetterFn);
    var elementIndex = this.elementBinders.length - 1;
    var bindingMemento = new DirectiveBindingMemento(elementIndex, directiveIndex, setterName, setter);
    var directiveMemento = this._getDirectiveMemento(elementIndex, directiveIndex);
    ListWrapper.push(this.bindingRecords, new BindingRecord(expression, bindingMemento, directiveMemento));
  },
  _getDirectiveMemento: function(elementInjectorIndex, directiveIndex) {
    assert.argumentTypes(elementInjectorIndex, assert.type.number, directiveIndex, assert.type.number);
    var id = elementInjectorIndex * 100 + directiveIndex;
    var protoElementInjector = this.elementBinders[elementInjectorIndex].protoElementInjector;
    if (!MapWrapper.contains(this._directiveMementosMap, id)) {
      var binding = protoElementInjector.getDirectiveBindingAtIndex(directiveIndex);
      MapWrapper.set(this._directiveMementosMap, id, new DirectiveMemento(elementInjectorIndex, directiveIndex, binding.callOnAllChangesDone));
    }
    return MapWrapper.get(this._directiveMementosMap, id);
  }
}, {
  buildEventHandler: function(eventMap, injectorIdx) {
    assert.argumentTypes(eventMap, Map, injectorIdx, int);
    var locals = MapWrapper.create();
    return (function(event, view) {
      if (view.hydrated()) {
        MapWrapper.set(locals, '$event', event);
        MapWrapper.forEach(eventMap, (function(expr, directiveIndex) {
          var context;
          if (directiveIndex === -1) {
            context = view.context;
          } else {
            context = view.elementInjectors[injectorIdx].getDirectiveAtIndex(directiveIndex);
          }
          expr.eval(context, new Locals(view.locals, locals));
        }));
      }
    });
  },
  createRootProtoView: function(protoView, insertionElement, rootComponentAnnotatedType, protoChangeDetector, shadowDomStrategy) {
    assert.argumentTypes(protoView, $ProtoView, insertionElement, assert.type.any, rootComponentAnnotatedType, DirectiveMetadata, protoChangeDetector, ProtoChangeDetector, shadowDomStrategy, ShadowDomStrategy);
    DOM.addClass(insertionElement, NG_BINDING_CLASS);
    var cmpType = rootComponentAnnotatedType.type;
    var rootProtoView = new $ProtoView(insertionElement, protoChangeDetector, shadowDomStrategy);
    rootProtoView.instantiateInPlace = true;
    var binder = rootProtoView.bindElement(null, 0, new ProtoElementInjector(null, 0, [cmpType], true));
    binder.componentDirective = rootComponentAnnotatedType;
    binder.nestedProtoView = protoView;
    shadowDomStrategy.shimAppElement(rootComponentAnnotatedType, insertionElement);
    return assert.returnType((rootProtoView), $ProtoView);
  }
});
Object.defineProperty(ProtoView, "parameters", {get: function() {
    return [[], [ProtoChangeDetector], [ShadowDomStrategy], [ProtoView]];
  }});
Object.defineProperty(ProtoView.prototype.instantiate, "parameters", {get: function() {
    return [[ElementInjector], [EventManager]];
  }});
Object.defineProperty(ProtoView.prototype._preFillPool, "parameters", {get: function() {
    return [[ElementInjector], [EventManager]];
  }});
Object.defineProperty(ProtoView.prototype._instantiate, "parameters", {get: function() {
    return [[ElementInjector], [EventManager]];
  }});
Object.defineProperty(ProtoView.prototype.returnToPool, "parameters", {get: function() {
    return [[View]];
  }});
Object.defineProperty(ProtoView.buildEventHandler, "parameters", {get: function() {
    return [[Map], [int]];
  }});
Object.defineProperty(ProtoView.prototype.bindVariable, "parameters", {get: function() {
    return [[assert.type.string], [assert.type.string]];
  }});
Object.defineProperty(ProtoView.prototype.bindElement, "parameters", {get: function() {
    return [[ElementBinder], [int], [ProtoElementInjector], [DirectiveMetadata], [DirectiveMetadata]];
  }});
Object.defineProperty(ProtoView.prototype.bindTextNode, "parameters", {get: function() {
    return [[int], [AST]];
  }});
Object.defineProperty(ProtoView.prototype.bindElementProperty, "parameters", {get: function() {
    return [[AST], [assert.type.string], [SetterFn]];
  }});
Object.defineProperty(ProtoView.prototype.bindEvent, "parameters", {get: function() {
    return [[assert.type.string], [AST], [int]];
  }});
Object.defineProperty(ProtoView.prototype.bindDirectiveProperty, "parameters", {get: function() {
    return [[assert.type.number], [AST], [assert.type.string], [SetterFn]];
  }});
Object.defineProperty(ProtoView.prototype._getDirectiveMemento, "parameters", {get: function() {
    return [[assert.type.number], [assert.type.number]];
  }});
Object.defineProperty(ProtoView.createRootProtoView, "parameters", {get: function() {
    return [[ProtoView], [], [DirectiveMetadata], [ProtoChangeDetector], [ShadowDomStrategy]];
  }});
var ElementBindingMemento = function ElementBindingMemento(elementIndex, setterName, setter) {
  assert.argumentTypes(elementIndex, int, setterName, assert.type.string, setter, SetterFn);
  this._elementIndex = elementIndex;
  this._setterName = setterName;
  this._setter = setter;
};
($traceurRuntime.createClass)(ElementBindingMemento, {invoke: function(record, bindElements) {
    assert.argumentTypes(record, ChangeRecord, bindElements, List);
    var element = bindElements[this._elementIndex];
    this._setter(element, record.currentValue);
  }}, {});
Object.defineProperty(ElementBindingMemento, "parameters", {get: function() {
    return [[int], [assert.type.string], [SetterFn]];
  }});
Object.defineProperty(ElementBindingMemento.prototype.invoke, "parameters", {get: function() {
    return [[ChangeRecord], [List]];
  }});
var DirectiveBindingMemento = function DirectiveBindingMemento(elementInjectorIndex, directiveIndex, setterName, setter) {
  assert.argumentTypes(elementInjectorIndex, assert.type.number, directiveIndex, assert.type.number, setterName, assert.type.string, setter, SetterFn);
  this._elementInjectorIndex = elementInjectorIndex;
  this._directiveIndex = directiveIndex;
  this._setterName = setterName;
  this._setter = setter;
};
($traceurRuntime.createClass)(DirectiveBindingMemento, {invoke: function(record, elementInjectors) {
    assert.argumentTypes(record, ChangeRecord, elementInjectors, assert.genericType(List, ElementInjector));
    var elementInjector = assert.type(elementInjectors[this._elementInjectorIndex], ElementInjector);
    var directive = elementInjector.getDirectiveAtIndex(this._directiveIndex);
    this._setter(directive, record.currentValue);
  }}, {});
Object.defineProperty(DirectiveBindingMemento, "parameters", {get: function() {
    return [[assert.type.number], [assert.type.number], [assert.type.string], [SetterFn]];
  }});
Object.defineProperty(DirectiveBindingMemento.prototype.invoke, "parameters", {get: function() {
    return [[ChangeRecord], [assert.genericType(List, ElementInjector)]];
  }});
var DirectiveMemento = function DirectiveMemento(elementInjectorIndex, directiveIndex, notifyOnAllChangesDone) {
  assert.argumentTypes(elementInjectorIndex, assert.type.number, directiveIndex, assert.type.number, notifyOnAllChangesDone, assert.type.boolean);
  this._elementInjectorIndex = elementInjectorIndex;
  this._directiveIndex = directiveIndex;
  this.notifyOnAllChangesDone = notifyOnAllChangesDone;
};
($traceurRuntime.createClass)(DirectiveMemento, {
  directive: function(elementInjectors) {
    assert.argumentTypes(elementInjectors, assert.genericType(List, ElementInjector));
    var elementInjector = assert.type(elementInjectors[this._elementInjectorIndex], ElementInjector);
    return elementInjector.getDirectiveAtIndex(this._directiveIndex);
  },
  directiveBinding: function(elementInjectors) {
    assert.argumentTypes(elementInjectors, assert.genericType(List, ElementInjector));
    var elementInjector = assert.type(elementInjectors[this._elementInjectorIndex], ElementInjector);
    return elementInjector.getDirectiveBindingAtIndex(this._directiveIndex);
  }
}, {});
Object.defineProperty(DirectiveMemento, "parameters", {get: function() {
    return [[assert.type.number], [assert.type.number], [assert.type.boolean]];
  }});
Object.defineProperty(DirectiveMemento.prototype.directive, "parameters", {get: function() {
    return [[assert.genericType(List, ElementInjector)]];
  }});
Object.defineProperty(DirectiveMemento.prototype.directiveBinding, "parameters", {get: function() {
    return [[assert.genericType(List, ElementInjector)]];
  }});
var PropertyUpdate = function PropertyUpdate(currentValue, previousValue) {
  this.currentValue = currentValue;
  this.previousValue = previousValue;
};
var $PropertyUpdate = PropertyUpdate;
($traceurRuntime.createClass)(PropertyUpdate, {}, {createWithoutPrevious: function(currentValue) {
    return new $PropertyUpdate(currentValue, uninitialized);
  }});
//# sourceMappingURL=view.js.map

//# sourceMappingURL=./view.map