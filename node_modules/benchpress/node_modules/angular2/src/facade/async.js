"use strict";
Object.defineProperties(module.exports, {
  Promise: {get: function() {
      return Promise;
    }},
  PromiseWrapper: {get: function() {
      return PromiseWrapper;
    }},
  Observable: {get: function() {
      return Observable;
    }},
  ObservableController: {get: function() {
      return ObservableController;
    }},
  ObservableWrapper: {get: function() {
      return ObservableWrapper;
    }},
  __esModule: {value: true}
});
var $__rtts_95_assert_47_rtts_95_assert__,
    $__angular2_47_src_47_facade_47_lang__,
    $__angular2_47_src_47_facade_47_collection__,
    $__rx_47_dist_47_rx_46_all__;
var assert = ($__rtts_95_assert_47_rtts_95_assert__ = require("rtts_assert/rtts_assert"), $__rtts_95_assert_47_rtts_95_assert__ && $__rtts_95_assert_47_rtts_95_assert__.__esModule && $__rtts_95_assert_47_rtts_95_assert__ || {default: $__rtts_95_assert_47_rtts_95_assert__}).assert;
var $__1 = ($__angular2_47_src_47_facade_47_lang__ = require("angular2/src/facade/lang"), $__angular2_47_src_47_facade_47_lang__ && $__angular2_47_src_47_facade_47_lang__.__esModule && $__angular2_47_src_47_facade_47_lang__ || {default: $__angular2_47_src_47_facade_47_lang__}),
    int = $__1.int,
    global = $__1.global,
    isPresent = $__1.isPresent;
var List = ($__angular2_47_src_47_facade_47_collection__ = require("angular2/src/facade/collection"), $__angular2_47_src_47_facade_47_collection__ && $__angular2_47_src_47_facade_47_collection__.__esModule && $__angular2_47_src_47_facade_47_collection__ || {default: $__angular2_47_src_47_facade_47_collection__}).List;
var Rx = ($__rx_47_dist_47_rx_46_all__ = require("rx/dist/rx.all"), $__rx_47_dist_47_rx_46_all__ && $__rx_47_dist_47_rx_46_all__.__esModule && $__rx_47_dist_47_rx_46_all__ || {default: $__rx_47_dist_47_rx_46_all__}).default;
var Promise = global.Promise;
var PromiseWrapper = function PromiseWrapper() {
  ;
};
($traceurRuntime.createClass)(PromiseWrapper, {}, {
  resolve: function(obj) {
    return assert.returnType((Promise.resolve(obj)), Promise);
  },
  reject: function(obj) {
    return assert.returnType((Promise.reject(obj)), Promise);
  },
  catchError: function(promise, onError) {
    assert.argumentTypes(promise, Promise, onError, Function);
    return assert.returnType((promise.catch(onError)), Promise);
  },
  all: function(promises) {
    assert.argumentTypes(promises, List);
    if (promises.length == 0)
      return assert.returnType((Promise.resolve([])), Promise);
    return assert.returnType((Promise.all(promises)), Promise);
  },
  then: function(promise, success, rejection) {
    assert.argumentTypes(promise, Promise, success, Function, rejection, Function);
    return assert.returnType((promise.then(success, rejection)), Promise);
  },
  completer: function() {
    var resolve;
    var reject;
    var p = new Promise(function(res, rej) {
      resolve = res;
      reject = rej;
    });
    return {
      promise: p,
      resolve: resolve,
      reject: reject
    };
  },
  setTimeout: function(fn, millis) {
    assert.argumentTypes(fn, Function, millis, int);
    global.setTimeout(fn, millis);
  },
  isPromise: function(maybePromise) {
    return assert.returnType((maybePromise instanceof Promise), assert.type.boolean);
  }
});
Object.defineProperty(PromiseWrapper.catchError, "parameters", {get: function() {
    return [[Promise], [Function]];
  }});
Object.defineProperty(PromiseWrapper.all, "parameters", {get: function() {
    return [[List]];
  }});
Object.defineProperty(PromiseWrapper.then, "parameters", {get: function() {
    return [[Promise], [Function], [Function]];
  }});
Object.defineProperty(PromiseWrapper.setTimeout, "parameters", {get: function() {
    return [[Function], [int]];
  }});
var Observable = Rx.Observable;
var ObservableController = Rx.Subject;
var ObservableWrapper = function ObservableWrapper() {
  ;
};
($traceurRuntime.createClass)(ObservableWrapper, {}, {
  createController: function() {
    return assert.returnType((new Rx.Subject()), Rx.Subject);
  },
  createObservable: function(subject) {
    assert.argumentTypes(subject, Rx.Subject);
    return assert.returnType((subject), Observable);
  },
  subscribe: function(observable, generatorOrOnNext) {
    var onThrow = arguments[2] !== (void 0) ? arguments[2] : null;
    var onReturn = arguments[3] !== (void 0) ? arguments[3] : null;
    if (isPresent(generatorOrOnNext.next)) {
      return observable.observeOn(Rx.Scheduler.timeout).subscribe((function(value) {
        return generatorOrOnNext.next(value);
      }), (function(error) {
        return generatorOrOnNext.throw(error);
      }), (function() {
        return generatorOrOnNext.return();
      }));
    } else {
      return observable.observeOn(Rx.Scheduler.timeout).subscribe(generatorOrOnNext, onThrow, onReturn);
    }
  },
  callNext: function(subject, value) {
    assert.argumentTypes(subject, Rx.Subject, value, assert.type.any);
    subject.onNext(value);
  },
  callThrow: function(subject, error) {
    assert.argumentTypes(subject, Rx.Subject, error, assert.type.any);
    subject.onError(error);
  },
  callReturn: function(subject) {
    assert.argumentTypes(subject, Rx.Subject);
    subject.onCompleted();
  }
});
Object.defineProperty(ObservableWrapper.createObservable, "parameters", {get: function() {
    return [[Rx.Subject]];
  }});
Object.defineProperty(ObservableWrapper.subscribe, "parameters", {get: function() {
    return [[Observable], [], [], []];
  }});
Object.defineProperty(ObservableWrapper.callNext, "parameters", {get: function() {
    return [[Rx.Subject], [assert.type.any]];
  }});
Object.defineProperty(ObservableWrapper.callThrow, "parameters", {get: function() {
    return [[Rx.Subject], [assert.type.any]];
  }});
Object.defineProperty(ObservableWrapper.callReturn, "parameters", {get: function() {
    return [[Rx.Subject]];
  }});
//# sourceMappingURL=async.es6.map

//# sourceMappingURL=./async.map