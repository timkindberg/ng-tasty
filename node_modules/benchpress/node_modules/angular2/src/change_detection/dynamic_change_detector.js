"use strict";
Object.defineProperties(module.exports, {
  DynamicChangeDetector: {get: function() {
      return DynamicChangeDetector;
    }},
  __esModule: {value: true}
});
var $__rtts_95_assert_47_rtts_95_assert__,
    $__angular2_47_src_47_facade_47_lang__,
    $__angular2_47_src_47_facade_47_collection__,
    $__abstract_95_change_95_detector__,
    $__pipes_47_pipe_95_registry__,
    $__change_95_detection_95_util__,
    $__proto_95_record__,
    $__exceptions__;
var assert = ($__rtts_95_assert_47_rtts_95_assert__ = require("rtts_assert/rtts_assert"), $__rtts_95_assert_47_rtts_95_assert__ && $__rtts_95_assert_47_rtts_95_assert__.__esModule && $__rtts_95_assert_47_rtts_95_assert__ || {default: $__rtts_95_assert_47_rtts_95_assert__}).assert;
var $__1 = ($__angular2_47_src_47_facade_47_lang__ = require("angular2/src/facade/lang"), $__angular2_47_src_47_facade_47_lang__ && $__angular2_47_src_47_facade_47_lang__.__esModule && $__angular2_47_src_47_facade_47_lang__ || {default: $__angular2_47_src_47_facade_47_lang__}),
    isPresent = $__1.isPresent,
    isBlank = $__1.isBlank,
    BaseException = $__1.BaseException,
    FunctionWrapper = $__1.FunctionWrapper;
var $__2 = ($__angular2_47_src_47_facade_47_collection__ = require("angular2/src/facade/collection"), $__angular2_47_src_47_facade_47_collection__ && $__angular2_47_src_47_facade_47_collection__.__esModule && $__angular2_47_src_47_facade_47_collection__ || {default: $__angular2_47_src_47_facade_47_collection__}),
    List = $__2.List,
    ListWrapper = $__2.ListWrapper,
    MapWrapper = $__2.MapWrapper,
    StringMapWrapper = $__2.StringMapWrapper;
var AbstractChangeDetector = ($__abstract_95_change_95_detector__ = require("./abstract_change_detector"), $__abstract_95_change_95_detector__ && $__abstract_95_change_95_detector__.__esModule && $__abstract_95_change_95_detector__ || {default: $__abstract_95_change_95_detector__}).AbstractChangeDetector;
var PipeRegistry = ($__pipes_47_pipe_95_registry__ = require("./pipes/pipe_registry"), $__pipes_47_pipe_95_registry__ && $__pipes_47_pipe_95_registry__.__esModule && $__pipes_47_pipe_95_registry__ || {default: $__pipes_47_pipe_95_registry__}).PipeRegistry;
var $__5 = ($__change_95_detection_95_util__ = require("./change_detection_util"), $__change_95_detection_95_util__ && $__change_95_detection_95_util__.__esModule && $__change_95_detection_95_util__ || {default: $__change_95_detection_95_util__}),
    ChangeDetectionUtil = $__5.ChangeDetectionUtil,
    uninitialized = $__5.uninitialized;
var $__6 = ($__proto_95_record__ = require("./proto_record"), $__proto_95_record__ && $__proto_95_record__.__esModule && $__proto_95_record__ || {default: $__proto_95_record__}),
    ProtoRecord = $__6.ProtoRecord,
    RECORD_TYPE_SELF = $__6.RECORD_TYPE_SELF,
    RECORD_TYPE_PROPERTY = $__6.RECORD_TYPE_PROPERTY,
    RECORD_TYPE_LOCAL = $__6.RECORD_TYPE_LOCAL,
    RECORD_TYPE_INVOKE_METHOD = $__6.RECORD_TYPE_INVOKE_METHOD,
    RECORD_TYPE_CONST = $__6.RECORD_TYPE_CONST,
    RECORD_TYPE_INVOKE_CLOSURE = $__6.RECORD_TYPE_INVOKE_CLOSURE,
    RECORD_TYPE_PRIMITIVE_OP = $__6.RECORD_TYPE_PRIMITIVE_OP,
    RECORD_TYPE_KEYED_ACCESS = $__6.RECORD_TYPE_KEYED_ACCESS,
    RECORD_TYPE_PIPE = $__6.RECORD_TYPE_PIPE,
    RECORD_TYPE_BINDING_PIPE = $__6.RECORD_TYPE_BINDING_PIPE,
    RECORD_TYPE_INTERPOLATE = $__6.RECORD_TYPE_INTERPOLATE;
var $__7 = ($__exceptions__ = require("./exceptions"), $__exceptions__ && $__exceptions__.__esModule && $__exceptions__ || {default: $__exceptions__}),
    ExpressionChangedAfterItHasBeenChecked = $__7.ExpressionChangedAfterItHasBeenChecked,
    ChangeDetectionError = $__7.ChangeDetectionError;
var DynamicChangeDetector = function DynamicChangeDetector(dispatcher, pipeRegistry, protoRecords, directiveMementos) {
  assert.argumentTypes(dispatcher, assert.type.any, pipeRegistry, PipeRegistry, protoRecords, assert.genericType(List, ProtoRecord), directiveMementos, List);
  $traceurRuntime.superConstructor($DynamicChangeDetector).call(this);
  this.dispatcher = dispatcher;
  this.pipeRegistry = pipeRegistry;
  this.values = ListWrapper.createFixedSize(protoRecords.length + 1);
  this.pipes = ListWrapper.createFixedSize(protoRecords.length + 1);
  this.prevContexts = ListWrapper.createFixedSize(protoRecords.length + 1);
  this.changes = ListWrapper.createFixedSize(protoRecords.length + 1);
  ListWrapper.fill(this.values, uninitialized);
  ListWrapper.fill(this.pipes, null);
  ListWrapper.fill(this.prevContexts, uninitialized);
  ListWrapper.fill(this.changes, false);
  this.locals = null;
  this.protos = protoRecords;
  this.directiveMementos = directiveMementos;
};
var $DynamicChangeDetector = DynamicChangeDetector;
($traceurRuntime.createClass)(DynamicChangeDetector, {
  hydrate: function(context, locals) {
    assert.argumentTypes(context, assert.type.any, locals, assert.type.any);
    this.values[0] = context;
    this.locals = locals;
  },
  dehydrate: function() {
    this._destroyPipes();
    ListWrapper.fill(this.values, uninitialized);
    ListWrapper.fill(this.changes, false);
    ListWrapper.fill(this.pipes, null);
    ListWrapper.fill(this.prevContexts, uninitialized);
    this.locals = null;
  },
  _destroyPipes: function() {
    for (var i = 0; i < this.pipes.length; ++i) {
      if (isPresent(this.pipes[i])) {
        this.pipes[i].onDestroy();
      }
    }
  },
  hydrated: function() {
    return assert.returnType((this.values[0] !== uninitialized), assert.type.boolean);
  },
  detectChangesInRecords: function(throwOnChange) {
    assert.argumentTypes(throwOnChange, assert.type.boolean);
    var protos = assert.type(this.protos, assert.genericType(List, ProtoRecord));
    var updatedRecords = null;
    for (var i = 0; i < protos.length; ++i) {
      var proto = assert.type(protos[i], ProtoRecord);
      var change = this._check(proto);
      if (isPresent(change)) {
        var record = ChangeDetectionUtil.changeRecord(proto.bindingMemento, change);
        updatedRecords = ChangeDetectionUtil.addRecord(updatedRecords, record);
      }
      if (proto.lastInDirective && isPresent(updatedRecords)) {
        if (throwOnChange)
          ChangeDetectionUtil.throwOnChange(proto, updatedRecords[0]);
        this.dispatcher.onRecordChange(proto.directiveMemento, updatedRecords);
        updatedRecords = null;
      }
    }
  },
  notifyOnAllChangesDone: function() {
    var mementos = this.directiveMementos;
    for (var i = mementos.length - 1; i >= 0; --i) {
      var memento = mementos[i];
      if (memento.notifyOnAllChangesDone) {
        this.dispatcher.onAllChangesDone(memento);
      }
    }
  },
  _check: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    try {
      if (proto.mode === RECORD_TYPE_PIPE || proto.mode === RECORD_TYPE_BINDING_PIPE) {
        return this._pipeCheck(proto);
      } else {
        return this._referenceCheck(proto);
      }
    } catch (e) {
      throw new ChangeDetectionError(proto, e);
    }
  },
  _referenceCheck: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    if (this._pureFuncAndArgsDidNotChange(proto)) {
      this._setChanged(proto, false);
      return null;
    }
    var prevValue = this._readSelf(proto);
    var currValue = this._calculateCurrValue(proto);
    if (!isSame(prevValue, currValue)) {
      this._writeSelf(proto, currValue);
      this._setChanged(proto, true);
      if (proto.lastInBinding) {
        return ChangeDetectionUtil.simpleChange(prevValue, currValue);
      } else {
        return null;
      }
    } else {
      this._setChanged(proto, false);
      return null;
    }
  },
  _calculateCurrValue: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    switch (proto.mode) {
      case RECORD_TYPE_SELF:
        return this._readContext(proto);
      case RECORD_TYPE_CONST:
        return proto.funcOrValue;
      case RECORD_TYPE_PROPERTY:
        var context = this._readContext(proto);
        return proto.funcOrValue(context);
      case RECORD_TYPE_LOCAL:
        return this.locals.get(proto.name);
      case RECORD_TYPE_INVOKE_METHOD:
        var context = this._readContext(proto);
        var args = this._readArgs(proto);
        return proto.funcOrValue(context, args);
      case RECORD_TYPE_KEYED_ACCESS:
        var arg = this._readArgs(proto)[0];
        return this._readContext(proto)[arg];
      case RECORD_TYPE_INVOKE_CLOSURE:
        return FunctionWrapper.apply(this._readContext(proto), this._readArgs(proto));
      case RECORD_TYPE_INTERPOLATE:
      case RECORD_TYPE_PRIMITIVE_OP:
        return FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto));
      default:
        throw new BaseException(("Unknown operation " + proto.mode));
    }
  },
  _pipeCheck: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    var context = this._readContext(proto);
    var pipe = this._pipeFor(proto, context);
    var newValue = pipe.transform(context);
    if (!ChangeDetectionUtil.noChangeMarker(newValue)) {
      var prevValue = this._readSelf(proto);
      this._writeSelf(proto, newValue);
      this._setChanged(proto, true);
      if (proto.lastInBinding) {
        return ChangeDetectionUtil.simpleChange(prevValue, newValue);
      } else {
        return null;
      }
    } else {
      this._setChanged(proto, false);
      return null;
    }
  },
  _pipeFor: function(proto, context) {
    assert.argumentTypes(proto, ProtoRecord, context, assert.type.any);
    var storedPipe = this._readPipe(proto);
    if (isPresent(storedPipe) && storedPipe.supports(context)) {
      return storedPipe;
    }
    if (isPresent(storedPipe)) {
      storedPipe.onDestroy();
    }
    var bpc = proto.mode === RECORD_TYPE_BINDING_PIPE ? this.bindingPropagationConfig : null;
    var pipe = this.pipeRegistry.get(proto.name, context, bpc);
    this._writePipe(proto, pipe);
    return pipe;
  },
  _readContext: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    return this.values[proto.contextIndex];
  },
  _readSelf: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    return this.values[proto.selfIndex];
  },
  _writeSelf: function(proto, value) {
    assert.argumentTypes(proto, ProtoRecord, value, assert.type.any);
    this.values[proto.selfIndex] = value;
  },
  _readPipe: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    return this.pipes[proto.selfIndex];
  },
  _writePipe: function(proto, value) {
    assert.argumentTypes(proto, ProtoRecord, value, assert.type.any);
    this.pipes[proto.selfIndex] = value;
  },
  _setChanged: function(proto, value) {
    assert.argumentTypes(proto, ProtoRecord, value, assert.type.boolean);
    this.changes[proto.selfIndex] = value;
  },
  _pureFuncAndArgsDidNotChange: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    return assert.returnType((proto.isPureFunction() && !this._argsChanged(proto)), assert.type.boolean);
  },
  _argsChanged: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    var args = proto.args;
    for (var i = 0; i < args.length; ++i) {
      if (this.changes[args[i]]) {
        return assert.returnType((true), assert.type.boolean);
      }
    }
    return assert.returnType((false), assert.type.boolean);
  },
  _readArgs: function(proto) {
    assert.argumentTypes(proto, ProtoRecord);
    var res = ListWrapper.createFixedSize(proto.args.length);
    var args = proto.args;
    for (var i = 0; i < args.length; ++i) {
      res[i] = this.values[args[i]];
    }
    return res;
  }
}, {}, AbstractChangeDetector);
Object.defineProperty(DynamicChangeDetector, "parameters", {get: function() {
    return [[assert.type.any], [PipeRegistry], [assert.genericType(List, ProtoRecord)], [List]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype.hydrate, "parameters", {get: function() {
    return [[assert.type.any], [assert.type.any]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype.detectChangesInRecords, "parameters", {get: function() {
    return [[assert.type.boolean]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._check, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._referenceCheck, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._calculateCurrValue, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._pipeCheck, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._pipeFor, "parameters", {get: function() {
    return [[ProtoRecord], []];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._readContext, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._readSelf, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._writeSelf, "parameters", {get: function() {
    return [[ProtoRecord], []];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._readPipe, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._writePipe, "parameters", {get: function() {
    return [[ProtoRecord], []];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._setChanged, "parameters", {get: function() {
    return [[ProtoRecord], [assert.type.boolean]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._argsChanged, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
Object.defineProperty(DynamicChangeDetector.prototype._readArgs, "parameters", {get: function() {
    return [[ProtoRecord]];
  }});
function isSame(a, b) {
  if (a === b)
    return true;
  if (a instanceof String && b instanceof String && a == b)
    return true;
  if ((a !== a) && (b !== b))
    return true;
  return false;
}
//# sourceMappingURL=dynamic_change_detector.js.map

//# sourceMappingURL=./dynamic_change_detector.map