import {isPresent,
  isBlank,
  BaseException,
  assertionsEnabled,
  RegExpWrapper} from 'angular2/src/facade/lang';
import {List,
  MapWrapper} from 'angular2/src/facade/collection';
import {DOM} from 'angular2/src/dom/dom_adapter';
import {SelectorMatcher} from '../selector';
import {CssSelector} from '../selector';
import {DirectiveMetadata} from '../directive_metadata';
import {DynamicComponent,
  Component,
  Viewport} from '../../annotations/annotations';
import {CompileStep} from './compile_step';
import {CompileElement} from './compile_element';
import {CompileControl} from './compile_control';
var PROPERTY_BINDING_REGEXP = RegExpWrapper.create('^ *([^\\s\\|]+)');
export class DirectiveParser extends CompileStep {
  constructor(directives) {
    super();
    var selector;
    this._selectorMatcher = new SelectorMatcher();
    for (var i = 0; i < directives.length; i++) {
      var directiveMetadata = directives[i];
      selector = CssSelector.parse(directiveMetadata.annotation.selector);
      this._selectorMatcher.addSelectables(selector, directiveMetadata);
    }
  }
  process(parent, current, control) {
    var attrs = current.attrs();
    var classList = current.classList();
    var cssSelector = new CssSelector();
    var nodeName = DOM.nodeName(current.element);
    cssSelector.setElement(nodeName);
    for (var i = 0; i < classList.length; i++) {
      cssSelector.addClassName(classList[i]);
    }
    MapWrapper.forEach(attrs, (attrValue, attrName) => {
      cssSelector.addAttribute(attrName, attrValue);
    });
    var isTemplateElement = DOM.isTemplateElement(current.element);
    this._selectorMatcher.match(cssSelector, (selector, directive) => {
      current.addDirective(checkDirectiveValidity(directive, current, isTemplateElement));
    });
  }
}
Object.defineProperty(DirectiveParser, "parameters", {get: function() {
    return [[assert.genericType(List, DirectiveMetadata)]];
  }});
Object.defineProperty(DirectiveParser.prototype.process, "parameters", {get: function() {
    return [[CompileElement], [CompileElement], [CompileControl]];
  }});
function checkDirectiveValidity(directive, current, isTemplateElement) {
  var isComponent = directive.annotation instanceof Component || directive.annotation instanceof DynamicComponent;
  var alreadyHasComponent = isPresent(current.componentDirective);
  if (directive.annotation instanceof Viewport) {
    if (!isTemplateElement) {
      throw new BaseException(`Viewport directives need to be placed on <template> elements or elements ` + `with template attribute - check ${current.elementDescription}`);
    } else if (isPresent(current.viewportDirective)) {
      throw new BaseException(`Only one viewport directive can be used per element - check ${current.elementDescription}`);
    }
  } else if (isTemplateElement) {
    throw new BaseException(`Only template directives are allowed on template elements - check ${current.elementDescription}`);
  } else if (isComponent && alreadyHasComponent) {
    throw new BaseException(`Multiple component directives not allowed on the same element - check ${current.elementDescription}`);
  }
  return directive;
}
//# sourceMappingURL=directive_parser.js.map

//# sourceMappingURL=./directive_parser.map